<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>		
<style>
	table {
		border-spacing: 0;
		margin: 0 auto;
	}
	td { 
		width: 70px;
		height: 70px;
	}
	.even {
		background: #F1F5C4;
	}
	.odd {
		background: #75756E;
	}
	.selected {
		background: #F2D0C7;
	}
</style>

</head>
<body>
	<table id="board">
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
	</table>
<script>
(function(){
	var Game = (function(){
		function Game() {
			this.boardMatrix = [[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7]];
			this._init = function() {
				var i, j, len, lngth, p, pProperties, c, src, pos;
				// window.onload = function() {
				this.board = new Board();
				// board.set();
				// };
				this.board.pieces = [
				{"type": "rook", "squares": ["00","07",
				"70", "77"], "srcs": ["imgs/white_rook.png", "imgs/black_rook.png"]}, 
				{"type": "pawn", "squares": 
				["10","11","12", "13","14","15","16", "17", "60","61",
				"62", "63","64","65","66","67"], "srcs": ["imgs/white_pawn.png", "imgs/black_pawn.png"]}, 
				{"type": "knight", "squares": ["01", "06","71","76"],"srcs": ["imgs/white_knight.png", "imgs/black_knight.png"]}, 
				{"type":"bishop", "squares": ["02","05","72","75"],"srcs": ["imgs/white_bishop.png", "imgs/black_bishop.png"]}, 
				{"type":"queen", "squares": ["03","73"],"srcs": ["imgs/white_queen.png", "imgs/black_queen.png"]}, 
				{"type": "king", "squares": ["04","74"],"srcs": ["imgs/white_king.png", "imgs/black_king.png"]}];
				this.board.positions = (function() {
					var obj = {}, i, j, len = this.boardMatrix.length;
					for (i = 0; i < len; i++) {
						for (j = 0; j < len; j++) {
							obj[i+""+j] = null;
						}
					}
					return obj;
				}).call(this);
				for(i = 0, len = this.board.pieces.length; i<len; i++) {
					p = this.board.pieces[i];
					for (j = 0, lngth = p.squares.length; j < lngth; j++) {
						c = j < lngth/2 ? "black" : "white";
						src = j < lngth/2 ? p.srcs[1] : p.srcs[0];
						pos = p.squares[j];
						pProperties = {"type": p.type, "square": pos, "color": c, "src": src};
						var newPiece = new Piece(pProperties);
						this.board.positions[pos] = newPiece;
					}
				}
				this.board.set(this.board.positions);
			}

			var Piece = (function() {
				function Piece(props) {
					this.type = props.type;
					this.starting_position = props.square;
					this.color = props.color;
					this.src = props.src;
					this.legalMoves(); 
				}
				Piece.prototype.legalMoves = function() {
					switch (this.type) {
						case "pawn":
							if (this.color == "white") {
								this.moves = [[-1,0]];
								this.eat = [[-1,-1],[-1,1]];
								this.firstMoves = [[-1,0], [-2,0]];
							} else {
								this.moves = [[1,0]];
								this.eat = [[1,1], [1,-1]];
								this.firstMoves = [[1,0], [2,0]];
							}
							this.moved = false;
							this.multiples = false;
							break;
						case "rook": 
						  this.moves = [[-1,0], [1,0], [0,-1], [0,1]];
						  this.multiples = true;
						  this.moved = false;
						  break;
						case "knight":
						  this.moves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
						  this.multiples = false;
						  break;
						case "queen":
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							break;
						case "king": 
							this.castleMoves = [[0,-2], [0,2]];
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							this.moved = false;
							break;
						case "bishop":
						  this.moves = [[1,1], [-1,-1], [-1,1], [1,-1]];
						  this.multiples = true;
						  break;
					}
				}
				return Piece;
			})();
			var Board = (function() {
				function Board() {
					var i, len;
					var that = this;
					this.valid;
					this.trn = "white";
					this.justCastled;
					this.board = document.getElementById("board");
					this.rows = document.querySelectorAll("tr"); 
					for (i = 0, len = this.rows.length; i < len; i++) {
						this.setSquares(this.rows[i], i);
					}
					this.board.onclick = function(e) {
						// what did we click on?
						var clicked = e.target, target, valid, piece;
						if (clicked.tagName == "TD") {
							targetEl = clicked;
							target = clicked.className.split(" ")[0];
						} else if (clicked.tagName == "IMG") {
							targetEl = clicked.parentNode;
							target = targetEl.className.split(" ")[0];
						}
						// if there was, and the target sq contains a different one of our pieces, select the other piece and unselect the old one.
						piece = that.positions[that.selected];
						if (that.selected) {
							// make sure it's not the same sq
							if (that.selected != target) {
								// we're trying to move to a different square
									if (that.positions[target] && that.positions[target].color == piece.color) {
										// remove the selected class from the last element
										that.selectedEl.className = that.selectedEl.className.replace("selected", "");
										// add it to the new one
										targetEl.className += " selected";
										that.selected = target;
										that.selectedEl = targetEl;
								} else {
// that.justCastled should be a contender for refactor since we probably shouldn't be calling methods (castle) that move pieces from within validMove, so should we check here whether we're trying to castle? or within movePiece?
									that.justCastled = false;
									if (that.validMove(piece, that.selected, target)) {
										if (!that.justCastled) that.movePiece(target, targetEl);
										that.turn(that.trn);
									}
								}
							}
						} else if (that.positions[target] && that.positions[target].color == that.trn) {
							// this means nothing has been selected yet
							that.selected = target;
							that.selectedEl = targetEl;
							targetEl.className += " selected";
						}
					}
					this.turn = function(color) {
						if (color == "white") {
							this.trn = "black";
						} else {
							this.trn = "white";
						} 
					}
				}
				Board.prototype.movePiece = function(target, targetEl) {
					// moves the elements
console.log("MOVEPIECE")
					var html = this.selectedEl.innerHTML;
					this.selectedEl.innerHTML = "";
					targetEl.innerHTML = html;
					// remove selected class
					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
					// update positions
					this.positions[target] = this.positions[this.selected];
					this.positions[this.selected] = null;
					// clear selected
					this.selected = null;
					this.selectedEl = null;
				}
 				Board.prototype.validMove = function(piece, from, to) {
 					var desiredShift = [~~to[0] - ~~from[0], ~~to[1] - ~~ from[1]];
 					var desiredStr = JSON.stringify(desiredShift);
 					var spotTaken = this.spotTaken(to);
 					var diffColors = this.positions[to] && this.positions[to].color != piece.color;
 					var cornerPiece, fromRow;
 					console.log(piece, "piece", desiredStr, "desiredStr");
 					console.log("moved", piece.moved);
 					if (piece.type == "pawn") {
// is it one of our primary moves?
						if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1) {
							if (!spotTaken) {
								if (!piece.moved) piece.moved = true;
								return true;
							}	
// are we trying to eat a piece?
						} else if (JSON.stringify(piece.eat).indexOf(desiredStr) != -1 && diffColors) {
								if (!piece.moved) piece.moved = true;
								return true;
// if nothing is valid so far, maybe it's our first move
						} else if (!piece.moved && JSON.stringify(piece.firstMoves).indexOf(desiredStr) != -1) {
// here we still need to check, is something in the way?? bc we could be moving 2 spaces up and running into something
								piece.moved = true;
								return true;
						} else {
							return false;
						}			
 					} else {
 						// we are not a pawn
 						// check if we're a king that's trying to castle 
console.log(piece.type, !piece.moved);
 						if (piece.type == "king" 
 							&& !piece.moved
 							&& JSON.stringify(piece.castleMoves).indexOf(desiredStr) != -1) { 
console.log("im a unmoved king with a valid move in the books");
 							fromRow = from[0];
 							if (desiredShift[1] < 0) {
 								// trying to castle left
 								cornerPiece = this.positions[fromRow + 0];
 								if (cornerPiece.type == "rook" 
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 1]
 									&& !this.positions[fromRow + 2]
 									&& !this.positions[fromRow + 3]) {
 									this.castle(piece,from,to,cornerPiece,fromRow+0,fromRow+3);
 									this.justCastled = true;
 									return true;
 								console.log("castleLeft");
 								}
 							} else {
 								// trying to castle right
 								cornerPiece = this.positions[fromRow + 7];
 								if (cornerPiece.type == "rook"
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 6]
 									&& !this.positions[fromRow + 5]) {

 									this.castle(piece,from,to,cornerPiece,fromRow+7,fromRow+5);
 									this.justCastled = true;
 									return true;
 								console.log("castleRight");
 								}
 							}
						}
						if (piece.multiples && (Math.abs(desiredShift[0]) > 1 || Math.abs(desiredShift[1]) > 1)) {
							// here we check if there's anything in our way
							if (this.multiples(piece, desiredShift, desiredStr, from, to)){
								return true;
							} else {
								return false;
							}
						} else {
							// not trying to move multiple squares
							if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1 && (diffColors || !spotTaken)) {
								return true;
							} else { return false; }
						}
 					}
 				}
 				Board.prototype.spotTaken = function(to) {
 					return this.positions[to] ?  true : false; 
 				}
 				Board.prototype.castle = function(king, kFrom, kTo, rook, rFrom, rTo) {

					king.moved = true;
					rook.moved = true;
 					var kingHTML = this.selectedEl.innerHTML;
 					var rookEl = document.getElementsByClassName(rFrom)[0];
 					var rookHTML = rookEl.innerHTML;
 					var kToEl = document.getElementsByClassName(kTo)[0];
 					var rToEl = document.getElementsByClassName(rTo)[0];
 					this.selectedEl.innerHTML = "";
 					rookEl.innerHTML = "";
 					kToEl.innerHTML = kingHTML;
 					rToEl.innerHTML = rookHTML;
 					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
 					// update positions
 					this.positions[kTo] = this.positions[kFrom];
 					this.positions[kFrom] = null;
 					this.positions[rTo] = this.positions[rFrom];
 					this.positions[rFrom] = null;
 					// clear selected
 					this.selected = null;
 					this.selectedEl = null;
 				}
 				Board.prototype.multiples = function(piece, desiredShift, desiredStr, from, to) {
 					var non_zero, direction, inBtwnSq,
 					startArr = [~~from[0],~~from[1]];
 					// is it a legal attempt?
 					var zeroIndex = desiredShift.indexOf(0);
					if (zeroIndex == -1 && Math.abs(desiredShift[0]) != Math.abs(desiredShift[1])) {
						return false;
					};
					// does one of our available moves match the desired move?
 					var r, c, i, j, len;
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					for (i = 0, len = piece.moves.length; i < len; i++) {
 						if (JSON.stringify([piece.moves[i][0] * r, piece.moves[i][1] * c]) == desiredStr) {
 							direction = piece.moves[i];
 							// are there any of our pieces in the way?
 							for (j = 0; j < (Math.max(r,c)-1); j++) {
// this seems sketchy to update startArr (contender for refactor)
 								startArr[0] = startArr[0] + direction[0];
 								startArr[1] = startArr[1] + direction[1];
 								inBtwnSq = startArr[0] + "" + startArr[1];
 								if (this.positions[inBtwnSq]) { return false;}
 							}
 							return true;
 						}
 					}
 					return false;
 				}
				Board.prototype.setSquares = function(row, index) {
					var i, len, color;
					var cols = row.querySelectorAll("td");
					for (i = 0, len = cols.length; i < len; i++) {
						color = (i + index) % 2 == 0 ? "even" : "odd";
						cols[i].setAttribute("class", index + "" + i + " " + color);
					}
				}
				Board.prototype.set = function(positions) {
					var i, len, piece, sq;
					var positionKeys = Object.keys(positions);
					for (i = 0, len = positionKeys.length; i < len; i++) {
						piece = positions[positionKeys[i]];
						if (piece) {
							sq = document.getElementsByClassName(piece.starting_position)[0];
							var img = document.createElement("img");
							img.src = piece.src;
							sq.appendChild(img);
						}
					}
				}
				return Board;
			})();
		this._init();
		}
		return Game;
	})();
	new Game();
})();
</script>	
</body>
</html>