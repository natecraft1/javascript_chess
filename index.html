<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>		
<style>
	table {
		border-spacing: 0;
		margin: 0 auto;
	}
	td { 
		width: 70px;
		height: 70px;
	}
	.even {
		background: #F1F5C4;
	}
	.odd {
		background: #75756E;
	}
	.selected {
		background: #F2D0C7;
	}
</style>

</head>
<body>
	<table id="board">
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
	</table>
<script>
(function(){
	var Game = (function(){
		function Game() {
			this.boardMatrix = [[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7]];
			this._init = function() {
				var i, j, len, lngth, p, pProperties, c, src, pos;
				// window.onload = function() {
				this.board = new Board();
				// board.set();
				// };
				this.board.pieces = [
				{"type": "rook", "squares": ["00","07",
				"70", "77"], "srcs": ["imgs/white_rook.png", "imgs/black_rook.png"]}, 
				{"type": "pawn", "squares": 
				["10","11","12", "13","14","15","16", "17", "60","61",
				"62", "63","64","65","66","67"], "srcs": ["imgs/white_pawn.png", "imgs/black_pawn.png"]}, 
				{"type": "knight", "squares": ["01", "06","71","76"],"srcs": ["imgs/white_knight.png", "imgs/black_knight.png"]}, 
				{"type":"bishop", "squares": ["02","05","72","75"],"srcs": ["imgs/white_bishop.png", "imgs/black_bishop.png"]}, 
				{"type":"queen", "squares": ["03","73"],"srcs": ["imgs/white_queen.png", "imgs/black_queen.png"]}, 
				{"type": "king", "squares": ["04","74"],"srcs": ["imgs/white_king.png", "imgs/black_king.png"]}];
				this.board.positions = (function() {
					var obj = {}, i, j, len = this.boardMatrix.length;
					for (i = 0; i < len; i++) {
						for (j = 0; j < len; j++) {
							obj[i+""+j] = null;
						}
					}
					return obj;
				}).call(this);

				this.board.kings = {"white": "74", "black": "04"};

				for(i = 0, len = this.board.pieces.length; i<len; i++) {
					p = this.board.pieces[i];
					for (j = 0, lngth = p.squares.length; j < lngth; j++) {
						c = j < lngth/2 ? "black" : "white";
						src = j < lngth/2 ? p.srcs[1] : p.srcs[0];
						pos = p.squares[j];
						pProperties = {"type": p.type, "square": pos, "color": c, "src": src};
						var newPiece = new Piece(pProperties);
						this.board.positions[pos] = newPiece;
						// this.board.immobile[pos] = false;
					}
				}
				this.board.set(this.board.positions);
			}

			var Piece = (function() {
				function Piece(props) {
					this.type = props.type;
					this.starting_position = props.square;
					this.color = props.color;
					this.src = props.src;
					this.legalMoves(); 
				}
				Piece.prototype.legalMoves = function() {
					switch (this.type) {
						case "pawn":
							if (this.color == "white") {
								this.moves = [[-1,0]];
								this.eat = [[-1,-1],[-1,1]];
								this.firstMoves = [[-1,0], [-2,0]];
							} else {
								this.moves = [[1,0]];
								this.eat = [[1,1], [1,-1]];
								this.firstMoves = [[1,0], [2,0]];
							}
							this.moved = false;
							this.multiples = false;
							break;
						case "rook": 
						  this.moves = [[-1,0], [1,0], [0,-1], [0,1]];
						  this.multiples = true;
						  this.moved = false;
						  break;
						case "knight":
						  this.moves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
						  this.multiples = false;
						  break;
						case "queen":
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							break;
						case "king": 
							this.castleMoves = [[0,-2], [0,2]];
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							this.moved = false;
							break;
						case "bishop":
						  this.moves = [[1,1], [-1,-1], [-1,1], [1,-1]];
						  this.multiples = true;
						  break;
					}
				}
				return Piece;
			})();
			var Board = (function() {
				function Board() {
					var i, len;
					var that = this;
					this.valid;
					this.trn = "white";
					this.justCastled;
					this.knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
					this.check = { "white": false, "black": false, "whiteEscapes": "", "blackEscapes": "" };
					this.checkPaths = { "white": [], "black": [], "whitePathHolder": "", "blackPathHolder": ""};
					this.board = document.getElementById("board");
					this.rows = document.querySelectorAll("tr"); 
					for (i = 0, len = this.rows.length; i < len; i++) {
						this.setSquares(this.rows[i], i);
					}
					this.board.onclick = function(e) {
						// what did we click on?
						var clicked = e.target, target, valid, piece, clearOfCheck;
						if (clicked.tagName == "TD") {
							targetEl = clicked;
							target = clicked.className.split(" ")[0];
						} else if (clicked.tagName == "IMG") {
							targetEl = clicked.parentNode;
							target = targetEl.className.split(" ")[0];
						}
						// if there was, and the target sq contains a different one of our pieces, select the other piece and unselect the old one.
						piece = that.positions[that.selected];
						if (that.selected && that.selected != target) {
							// we're not trying to move to a different square
							if (that.positions[target] && that.positions[target].color == piece.color) {
									// remove the selected class from the last element
									that.selectedEl.className = that.selectedEl.className.replace("selected", "");
									// add it to the new one
									targetEl.className += " selected";
									that.selected = target;
									that.selectedEl = targetEl;
							} else {
// that.justCastled should be a contender for refactor since we probably shouldn't be calling methods (castle) that move pieces from within validMove, so should we check here whether we're trying to castle? or within movePiece?
								that.justCastled = false;
// if we're in check we need to check for both validmoveincheck as well as valid move, else, just validmove
								if (!that.check[piece.color]) {
									clearOfCheck = true;
								} else {
									if (that.validMoveInCheck(piece, target)) {
										clearOfCheck = true;
									} else { clearOfCheck = false; }
								}
								if (clearOfCheck && that.validMove(piece, that.selected, target)) {
									if (!that.justCastled) that.movePiece(target, targetEl);
									that.setCheck(piece, target);
									that.turn(that.trn);
									if (piece.type == "king") that.kings[piece.color] = target;
								}
							}
						} else if (that.positions[target] && that.positions[target].color == that.trn) {
							// this means nothing has been selected yet
							that.selected = target;
							that.selectedEl = targetEl;
							targetEl.className += " selected";
						}
					}
					this.turn = function(color) {
						if (color == "white") {
							this.trn = "black";
						} else {
							this.trn = "white";
						} 
					}
				}
				Board.prototype.setCheck = function(piece, newSq) {
					// are they in check?
					var opponent = this.trn == "white" ? "black" : "white";
					var oppInCheck = this.check[opponent];
					var type = piece.type;
					var distFromKing, pathBlocked, oppKingSq =	this.kings[opponent];
					
					if (type == "pawn" || type == "knight") {
						var checkMoves = type == "pawn" ? piece.eat : piece.moves;
						var potentialChecks = (function() {
							var i, d1, d2, len, arr = [];
							for (i = 0, len = checkMoves.length; i < len; i++) {
								d1 = ~~newSq[0] + checkMoves[i][0];
								d2 = ~~newSq[1] + checkMoves[i][1];
								arr.push(d1 + "" + d2);
							}
							return arr;
						})();
// POTENTIAL REFACTOR BC THIS LOGIC IS BEING REPEATED IN THE ELSE STATEMENT AS WELL 
						var check = potentialChecks.indexOf(oppKingSq) == -1 ? false : true;
						if (oppInCheck != check) { 
							this.check[opponent] = check; 
						}
						if (this.check[opponent]) { 
							if (!this.checkMate(opponent)) {

							} else {
								this.gameOver();
							}
						}
					} else {
						// not a knight or pawn
						// first check if it's possible
						distFromKing = [~~oppKingSq[0] - ~~newSq[0], ~~oppKingSq[1] - ~~ newSq[1]];
						if (this.validDirection(distFromKing)) {
							// it's possible that the opp is in check
							// if it's not impeded opp is in check
							if (piece.multiples) {
								pathBlocked = this.pathBlocked(piece, distFromKing, JSON.stringify(distFromKing), newSq, opponent);
							}
							
							this.check[opponent] = !pathBlocked;
							if (typeof pathBlocked == "string") { this.immobile[pathBlocked] = true; }
							if (!pathBlocked) { 
								if (!this.checkMate(opponent, distFromKing)) {
								} else {
									this.gameOver();
								}
							}
						}
					}
					// CAREFUL HERE, but I think we need to reset this every turn.	
					// this.check[opponent + "Escapes"] = ""; 
				}
				Board.prototype.gameOver = function() {
					console.log("gg");
				}
				Board.prototype.checkMate = function(opponent, distFromKing) {
					var i, len, sq;
					var oppKingSq = this.kings[opponent];
					var oppKing = this.positions[oppKingSq];
					var possibleKingMoves = [];
					var surroundingSqs = (function() {
						var arr = [];
						var i, len, f, s, combined;
						for (i = 0, len = oppKing.moves.length; i<len; i++) {
							f = ~~oppKingSq[0] + oppKing.moves[i][0];
							s = ~~oppKingSq + oppKing.moves[i][1];
						  combined = f + "" + s;
						  if (combined in this.positions) {
						  	arr.push(combined);
						  }
						}
						return arr;
					}).call(this);
					for (i = 0, len = surroundingSqs.length; i < len; i++) {
						sq = surroundingSqs[i];
						if (!this.positions[sq] || this.positions[sq].color !== opponent) {
							possibleKingMoves.push(sq);
						} 
					}
					var kingMoves = this.possibleKingMove(possibleKingMoves, oppKing.moves, opponent);
					var canBeSaved = this.canBeSaved(opponent);
					if (kingMoves.length || canBeSaved) { 
						return false; 
					} else {
						return true;
					}
				}
				Board.prototype.swap = function(color) {
					return color == "white" ? "black" : "white";
				}
				Board.prototype.canBeSaved = function(color) {
					// here we check if ANY of the opps pieces can move to one of our checkPath sqs
					var i, len, dist, direction, j, lngth, moves, moveTo, piece, l, z, pFirstMove, pEatMove, pForwardMove;
					var resqueSqs = this.checkPaths[color];
					for (var sqr in this.positions) {
						piece = this.positions[sqr];
						if (piece && piece.color == color) {
							if (piece.multiples) {
								for (i = 0, len = resqueSqs.length; i < len; i++) {
									dist = this.distBtwnSqs(sqr, resqueSqs[i]);

									if (this.validDirection(dist)) {
										direction = this.validPieceDirection(piece, Math.abs(dist[0]), Math.abs(dist[1]), JSON.stringify(dist));
										if (direction) {
											if (this.clearPath(sqr, Math.abs(dist[0]), Math.abs(dist[1]), direction)) {
												return true;
											}
										}
									}
								}
							} else if (piece.type == "knight") {
								moves = piece.moves;
								for (j = 0, lngth = moves.length; j < lngth; j++) {
									moveTo = (~~sqr[0] + moves[j][0]) + "" + (~~sqr[1] + moves[j][1]);
									if (resqueSqs.indexOf(moveTo) != -1) {
										return true;
									}
								}
							} else {
								// we're a pawn
								for (l = 0; l < piece.eat.length; l++) {
									pEatMove = (~~sqr[0] + piece.eat[l][0]) + "" + (~~sqr[1] + piece.eat[l][1]);
									if (this.checkPaths[color + "PathHolder"] == pEatMove) {
										return true;
									}
								}
								if (this.pawnLegalMoves(sqr, piece.firstMoves[0], color)) {
									return true;
								}
								if (!piece.moved) {
									if (this.pawnLegalMoves(sqr, piece.firstMoves[1], color)) {
										return true;
									}
								} 
							}
						}
					}
					return false;
				}
				Board.prototype.pawnLegalMoves = function(sqr, move, color) {
					var mv;
					mv = (~~sqr[0] + move[0]) + "" + (~~sqr[1] + move[1]);
					if (this.checkPaths[color].indexOf(mv) != -1) {
						return true;
					} 
				}
				Board.prototype.distBtwnSqs = function(from, to) {
					// takes 2 sqs and returns an array of the shift we're trying to make
					return [~~to[0] - ~~from[0], ~~to[1] - ~~from[1]]
				}
				Board.prototype.possibleMove = function() {

				}
				Board.prototype.possibleKingMove = function(sqs, moves, opponent) {
					var i, len, k, lenth, knt, j, lngth, p, f, ff, s, ss, next, path, strMove, potentialPawnMove, pawnMoves;
					var validMoves = [];
					// we have to walk all directions until we hit one of our own, an opponent, or to the end of the board
					allSqs: for (i = 0, len = sqs.length; i < len; i++) {
						f = ~~sqs[i][0], s = ~~sqs[i][1];
						// check for knights
						for (k = 0, length = this.knightMoves.length; k < lenth; k++) {
							knt = (f + this.knightMoves[k][0]) + "" + (s + this.knightMoves[k][1]); 
							if (this.positions[knt] 
								&& this.positions[knt].type == "knight" 
								&& this.positions[knt].color != opponent) {
								continue allSqs;
							}
						}
						// check for pawns
						for (p = 0; p < 2; p++) {
							if (opponent == "black") {
								pawnMoves = [[-1, -1], [-1, 1]];
							} else if (opponent == "white") {
								pawnMoves = [[1, -1], [1, 1]];
							}
							potentialPawnMove = (f + pawnMoves[p][0]) + "" + (s + pawnMoves[p][1]);
							if (this.positions[potentialPawnMove] 
								&& this.positions[potentialPawnMove].type == "pawn"
								&& this.positions[potentialPawnMove].color != opponent) {
								continue allSqs;
							}
						}
					allMoves:	for (j = 0, lngth = moves.length; j < lngth; j++) {
							// conditions for break:
							strMove = JSON.stringify(moves[j]);
							ff = f, ss = s;
							// we reach the end of the board
							while (ff < 7 && ff > 0 && ss < 7 && ss > 0) {
								ff += moves[j][0];
								ss += moves[j][1];
								next = ff + "" + ss;
								if (this.positions[next]) {
									if (this.positions[next].color == opponent) {
										// we hit our own piece
										break;
									} else {
										if (JSON.stringify(this.positions[next].moves).indexOf(strMove) != -1) {
											continue allSqs;
											// we hit an opp piece that doesn't share the path
										} else { continue allMoves; }
									}
								}
							}
						}
						// we found a free sq
						validMoves.push(sqs[i]);
					}
					if (validMoves.length > 0) {
						this.check[opponent + "Escapes"] = validMoves;
					}
					return validMoves;
				}
				Board.prototype.movePiece = function(target, targetEl) {
					// moves the elements
					var html = this.selectedEl.innerHTML;
					this.selectedEl.innerHTML = "";
					targetEl.innerHTML = html;
					// remove selected class
					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
					// update positions
					this.positions[target] = this.positions[this.selected];
					this.positions[this.selected] = null;
					// clear selected
					this.selected = null;
					this.selectedEl = null;
				}
				Board.prototype.validMoveInCheck = function(piece, to) {
					if (piece.type == "king" 
						&& this.check[piece.color + "Escapes"].indexOf(to)) {
						this.check[piece.color] = false;
						return true;
					} else {
						if (this.checkPaths[piece.color].indexOf(to) != -1 
							|| this.checkPaths[piece.color + "PathHolder"] == to) {
							return true;
						} 
					}
				}
 				Board.prototype.validMove = function(piece, from, to) {
					// are we already in check??					
 					var desiredShift = this.distBtwnSqs(from, to);
 					var desiredStr = JSON.stringify(desiredShift);
 					var spotTaken = this.spotTaken(to);
 					var diffColors = this.positions[to] && this.positions[to].color != piece.color;
 					var cornerPiece, fromRow;
 					if (piece.type == "pawn") {
// is it one of our primary moves?
						if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1) {
							if (!spotTaken) {
								if (!piece.moved) piece.moved = true;
// return to
								return true;
							}	
// are we trying to eat a piece?
						} else if (JSON.stringify(piece.eat).indexOf(desiredStr) != -1 && diffColors) {
								if (!piece.moved) piece.moved = true;
								return true;
// if nothing is valid so far, maybe it's our first move
						} else if (!piece.moved && JSON.stringify(piece.firstMoves).indexOf(desiredStr) != -1) {
// here we still need to check, is something in the way?? bc we could be moving 2 spaces up and running into something
								piece.moved = true;
								return true;
						} else {
							return false;
						}			
 					} else {
 						// we are not a pawn
 						// check if we're a king that's trying to castle 
 						if (piece.type == "king" 
 							&& !piece.moved
 							&& JSON.stringify(piece.castleMoves).indexOf(desiredStr) != -1) { 
 							fromRow = from[0];
 							if (desiredShift[1] < 0) {
 								// trying to castle left
 								cornerPiece = this.positions[fromRow + 0];
 								if (cornerPiece.type == "rook" 
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 1]
 									&& !this.positions[fromRow + 2]
 									&& !this.positions[fromRow + 3]) {
 									this.castle(piece,from,to,cornerPiece,fromRow+0,fromRow+3);
 									this.justCastled = true;
 									return true;
 								}
 							} else {
 								// trying to castle right
 								cornerPiece = this.positions[fromRow + 7];
 								if (cornerPiece.type == "rook"
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 6]
 									&& !this.positions[fromRow + 5]) {

 									this.castle(piece,from,to,cornerPiece,fromRow+7,fromRow+5);
 									this.justCastled = true;
 									return true;
 								}
 							}
						}
						if (piece.multiples && (Math.abs(desiredShift[0]) > 1 || Math.abs(desiredShift[1]) > 1)) {
							// here we check if there's anything in our way
							var r = Math.abs(desiredShift[0]);
							var c = Math.abs(desiredShift[1]);
							var dir = this.validPieceDirection(piece, r, c, desiredStr);
							if (this.validDirection(desiredShift) 
								&& dir
								&& this.clearPath(from, r, c, dir)) {
								return true;
							} else {
								return false;
							}
						} else {
							// not trying to move multiple squares
							if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1 && (diffColors || !spotTaken)) {
								return true;
							} else { return false; }
						}
 					}
 				}
 				Board.prototype.spotTaken = function(to) {
 					return this.positions[to] ?  true : false; 
 				}
 				Board.prototype.castle = function(king, kFrom, kTo, rook, rFrom, rTo) {
 					this.kings[king.color] = kTo;
					king.moved = true;
					rook.moved = true;
 					var kingHTML = this.selectedEl.innerHTML;
 					var rookEl = document.getElementsByClassName(rFrom)[0];
 					var rookHTML = rookEl.innerHTML;
 					var kToEl = document.getElementsByClassName(kTo)[0];
 					var rToEl = document.getElementsByClassName(rTo)[0];
 					this.selectedEl.innerHTML = "";
 					rookEl.innerHTML = "";
 					kToEl.innerHTML = kingHTML;
 					rToEl.innerHTML = rookHTML;
 					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
 					// update positions
 					this.positions[kTo] = this.positions[kFrom];
 					this.positions[kFrom] = null;
 					this.positions[rTo] = this.positions[rFrom];
 					this.positions[rFrom] = null;
 					// clear selected
 					this.selected = null;
 					this.selectedEl = null;
 				}
 				Board.prototype.validDirection = function(desiredShift) {
 					var r, c;
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					// is it a legal attempt?
 					var zeroIndex = desiredShift.indexOf(0);
					if (zeroIndex == -1 && r != c) {
						return false;
					} else { return true };

 				}
 				Board.prototype.validPieceDirection = function(piece, r, c, desiredStr) {
					var zero = [r,c].indexOf(0);
					for (i = 0, len = piece.moves.length; i < len; i++) {
						// run it if there is no zero, or if zeros match
						if (zero == -1 || piece.moves[i][zero] == 0) {
							if (JSON.stringify([piece.moves[i][0] * r, piece.moves[i][1] * c]) == desiredStr) {
								return piece.moves[i];
							}
						}
					}
 				}
 				Board.prototype.clearPath = function(from, r, c, direction) {
 					var startArr = [~~from[0],~~from[1]];
 					var j;
					for (j = 0; j < (Math.max(r,c)-1); j++) {
// this seems sketchy to update startArr (contender for refactor)
						startArr[0] = startArr[0] + direction[0];
						startArr[1] = startArr[1] + direction[1];
						inBtwnSq = startArr[0] + "" + startArr[1];
						if (this.positions[inBtwnSq]) {
							return false;
						}
					}
					return true;
 				}
 				Board.prototype.pathBlocked = function(piece, desiredShift, desiredStr, from, opponent) {
 					// var opponent = this.trn == "white" ? "black" : "white";
 					var non_zero, direction, inBtwnSq, r, c, i, j, len, startArr, inBtwnSqs;
 				// 	r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					startArr = [~~from[0],~~from[1]];
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);

					// does one of our available moves match the desired move?
					var validPD = this.validPieceDirection(piece, r, c, desiredStr);
 					if (validPD) {
						direction = validPD;
						inBtwnSqs = [];
						// are there any of our pieces in the way?
						for (j = 0; j < (Math.max(r,c)-1); j++) {
// this seems sketchy to update startArr (contender for refactor)
							startArr[0] = startArr[0] + direction[0];
							startArr[1] = startArr[1] + direction[1];
							inBtwnSq = startArr[0] + "" + startArr[1];
							if (this.positions[inBtwnSq]) { 
								inBtwnSqs = [];
								return inBtwnSq; 
							} else {
								inBtwnSqs.push(inBtwnSq);
							}
						}
						// this means we checked all the squares and there was nothing
						// save them in the check path
						if (opponent) { 
							this.checkPaths[opponent] = inBtwnSqs; 
							this.checkPaths[opponent + "PathHolder"] = from;
						}
						return false;
 					} else {
 						return true;
 					}
 				}

				Board.prototype.setSquares = function(row, index) {
					var i, len, color;
					var cols = row.querySelectorAll("td");
					for (i = 0, len = cols.length; i < len; i++) {
						color = (i + index) % 2 == 0 ? "even" : "odd";
						cols[i].setAttribute("class", index + "" + i + " " + color);
					}
				}
				Board.prototype.set = function(positions) {
					var i, len, piece, sq;
					var positionKeys = Object.keys(positions);
					for (i = 0, len = positionKeys.length; i < len; i++) {
						piece = positions[positionKeys[i]];
						if (piece) {
							sq = document.getElementsByClassName(piece.starting_position)[0];
							var img = document.createElement("img");
							img.src = piece.src;
							sq.appendChild(img);
						}
					}
				}
				return Board;
			})();
		this._init();
		}
		return Game;
	})();
	new Game();
})();
</script>	
</body>
</html>