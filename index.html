<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>		
<style>
	table {
		border-spacing: 0;
		margin: 0 auto;
	}
	td { 
		width: 70px;
		height: 70px;
	}
	.even {
		background: #F1F5C4;
	}
	.odd {
		background: #75756E;
	}
	.selected {
		background: #F2D0C7;
	}
</style>

</head>
<body>
	<table id="board">
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
	</table>
<script>
(function(){
	var Game = (function(){
		function Game() {
			this.boardMatrix = [[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7]];
			this._init = function() {
				var i, j, len, lngth, p, pProperties, c, src, pos;
				// window.onload = function() {
				this.board = new Board();
				// board.set();
				// };
				this.board.pieces = [
				{"type": "rook", "squares": ["00","07",
				"70", "77"], "srcs": ["imgs/white_rook.png", "imgs/black_rook.png"]}, 
				{"type": "pawn", "squares": 
				["10","11","12", "13","14","15","16", "17", "60","61",
				"62", "63","64","65","66","67"], "srcs": ["imgs/white_pawn.png", "imgs/black_pawn.png"]}, 
				{"type": "knight", "squares": ["01", "06","71","76"],"srcs": ["imgs/white_knight.png", "imgs/black_knight.png"]}, 
				{"type":"bishop", "squares": ["02","05","72","75"],"srcs": ["imgs/white_bishop.png", "imgs/black_bishop.png"]}, 
				{"type":"queen", "squares": ["03","73"],"srcs": ["imgs/white_queen.png", "imgs/black_queen.png"]}, 
				{"type": "king", "squares": ["04","74"],"srcs": ["imgs/white_king.png", "imgs/black_king.png"]}];
				this.board.positions = (function() {
					var obj = {}, i, j, len = this.boardMatrix.length;
					for (i = 0; i < len; i++) {
						for (j = 0; j < len; j++) {
							obj[i+""+j] = null;
						}
					}
					return obj;
				}).call(this);

				this.board.kings = {"white": "74", "black": "04"};

				for(i = 0, len = this.board.pieces.length; i<len; i++) {
					p = this.board.pieces[i];
					for (j = 0, lngth = p.squares.length; j < lngth; j++) {
						c = j < lngth/2 ? "black" : "white";
						src = j < lngth/2 ? p.srcs[1] : p.srcs[0];
						pos = p.squares[j];
						pProperties = {"type": p.type, "square": pos, "color": c, "src": src};
						var newPiece = new Piece(pProperties);
						this.board.positions[pos] = newPiece;
						// this.board.immobile[pos] = false;
					}
				}
				this.board.set(this.board.positions);
			}

			var Piece = (function() {
				function Piece(props) {
					this.type = props.type;
					this.starting_position = props.square;
					this.color = props.color;
					this.src = props.src;
					this.legalMoves(); 
				}
				Piece.prototype.legalMoves = function() {
					switch (this.type) {
						case "pawn":
							if (this.color == "white") {
								this.moves = [[-1,0]];
								this.eat = [[-1,-1],[-1,1]];
								this.firstMoves = [[-1,0], [-2,0]];
							} else {
								this.moves = [[1,0]];
								this.eat = [[1,1], [1,-1]];
								this.firstMoves = [[1,0], [2,0]];
							}
							this.moved = false;
							this.multiples = false;
							break;
						case "rook": 
						  this.moves = [[-1,0], [1,0], [0,-1], [0,1]];
						  this.multiples = true;
						  this.moved = false;
						  break;
						case "knight":
						  this.moves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
						  this.multiples = false;
						  break;
						case "queen":
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							break;
						case "king": 
							this.castleMoves = [[0,-2], [0,2]];
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							this.moved = false;
							break;
						case "bishop":
						  this.moves = [[1,1], [-1,-1], [-1,1], [1,-1]];
						  this.multiples = true;
						  break;
					}
				}
				return Piece;
			})();
			var Board = (function() {
				function Board() {
					var i, len;
					var that = this;
					this.valid;
					this.trn = "white";
					this.justCastled;
					this.knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
					this.check = { "white": false, "black": false, "whiteEscapes": [], "blackEscapes": [] };
					this.checkPaths = { "white": [], "black": [], "whitePathHolder": "", "blackPathHolder": ""};
					this.immobile = {"white": null, "black": null};
					this.board = document.getElementById("board");
					this.rows = document.querySelectorAll("tr"); 
					for (i = 0, len = this.rows.length; i < len; i++) {
						this.setSquares(this.rows[i], i);
					}
					this.board.onclick = function(e) {
						// what did we click on?
						var clicked = e.target, target, valid, piece, clearOfCheck;
						if (clicked.tagName == "TD") {
							targetEl = clicked;
							target = clicked.className.split(" ")[0];
						} else if (clicked.tagName == "IMG") {
							targetEl = clicked.parentNode;
							target = targetEl.className.split(" ")[0];
						}
						// if there was, and the target sq contains a different one of our pieces, select the other piece and unselect the old one.
						piece = that.positions[that.selected];
						if (that.selected && that.selected != target) {
							// we're not trying to move to a different square
							if (that.positions[target] && that.positions[target].color == piece.color) {
									// remove the selected class from the last element
									that.selectedEl.className = that.selectedEl.className.replace("selected", "");
									// add it to the new one
									targetEl.className += " selected";
									that.selected = target;
									that.selectedEl = targetEl;
							} else {
// that.justCastled should be a contender for refactor since we probably shouldn't be calling methods (castle) that move pieces from within validMove, so should we check here whether we're trying to castle? or within movePiece?
								that.justCastled = false;
// if we're in check we need to check for both validmoveincheck as well as valid move, else, just validmove
								that.checkOppPaths(that.selected, target, piece.color);
								if (!that.check[piece.color]) {
									clearOfCheck = true;
								} else {
									if (that.validMoveInCheck(piece, target)) {
										clearOfCheck = true;
									} else { clearOfCheck = false; }
								}
								if (clearOfCheck 
									&& that.immobile[piece.color] != that.selected
									&& that.validMove(piece, that.selected, target)) {
									if (!that.justCastled) that.movePiece(target, targetEl);
									that.setCheck(piece, target);
									that.turn(that.trn);
console.log("immobile", that.immobile);
									// if you make a valid move, and it's into one of the opps' path sqs
console.log(that.check);
console.log(that.checkPaths);
									if (piece.type == "king") that.kings[piece.color] = target;
								}
							}
						} else if (that.positions[target] && that.positions[target].color == that.trn) {
							// this means nothing has been selected yet
							that.selected = target;
							that.selectedEl = targetEl;
							targetEl.className += " selected";
						}
					}
					this.turn = function(color) {
						if (color == "white") {
							this.trn = "black";
						} else {
							this.trn = "white";
						} 
					}
				}

				Board.prototype.setCheck = function(piece, newSq) {
					// are they in check?
					if (this.check[piece.color]) {
						this.resetCheckProperties(piece, newSq);
						return;
					}
					var opponent = this.trn == "white" ? "black" : "white";
					var oppInCheck = this.check[opponent];
					var type = piece.type;
					var distFromKing, pathBlocked, oppKingSq =	this.kings[opponent];
					
					if (type == "pawn" || type == "knight") {
						var checkMoves = type == "pawn" ? piece.eat : piece.moves;
						var potentialChecks = (function() {
							var i, d1, d2, len, arr = [];
							for (i = 0, len = checkMoves.length; i < len; i++) {
								d1 = ~~newSq[0] + checkMoves[i][0];
								d2 = ~~newSq[1] + checkMoves[i][1];
								arr.push(d1 + "" + d2);
							}
							return arr;
						})();
// POTENTIAL REFACTOR BC THIS LOGIC IS BEING REPEATED IN THE ELSE STATEMENT AS WELL 
						var check = potentialChecks.indexOf(oppKingSq) == -1 ? false : true;
						if (oppInCheck != check) { 
							this.check[opponent] = check; 
						}
						if (this.check[opponent]) { 
							if (!this.checkMate(opponent)) {

							} else {
								this.gameOver();
							}
						}
					} else {
						// not a knight or pawn
						// first check if it's possible
						distFromKing = [~~oppKingSq[0] - ~~newSq[0], ~~oppKingSq[1] - ~~ newSq[1]];
						if (this.validDirection(distFromKing)) {
							// it's possible that the opp is in check
							// if it's not impeded opp is in check
							if (piece.multiples) {
								pathBlocked = this.pathBlocked(piece, distFromKing, JSON.stringify(distFromKing), newSq, opponent);
							}
							this.check[opponent] = !pathBlocked;
							// if (typeof pathBlocked == "object") { console.log("hello world"); this.immobile[pathBlocked] = true; }
							if (!pathBlocked) { 
								if (!this.checkMate(opponent, distFromKing)) {
								} else {
									this.gameOver();
								}
							}
						}
					}
				}
				Board.prototype.gameOver = function() {
					console.log("gg");
				}
				Board.prototype.checkOppPaths = function(from, to, color) {
					var opp = this.swap(color), i, lngth, paths;
					var paths = this.checkPaths[opp];
					if (paths.length > 0) {
						// are we trying to move from or to the path?
						if (paths.indexOf(from) != -1) {
							// allowed if there's another piece in the path - pathholder
							for (i = 0, lngth = paths.length; i < lngth; i++) {
								if (this.positions[paths[i]] 
									&& paths[i] != this.checkPaths[opp + "PathHolder"]) {
									return true;
								}
							}
							// didnt find somehting else in the path;
							// we return false because you can't move from a sq if it will put u in check
							return false;
						} else if (paths.indexOf(to) != -1) {

						} else {

						}
					} else {
						return true;
					}
					
				}
				Board.prototype.checkMate = function(opponent, distFromKing) {
					var i, len, sq;
					var oppKingSq = this.kings[opponent];
					var oppKing = this.positions[oppKingSq];
					var possibleKingMoves = [];
					var surroundingSqs = (function() {
						var arr = [];
						var i, len, f, s, combined;
						for (i = 0, len = oppKing.moves.length; i<len; i++) {
							f = ~~oppKingSq[0] + oppKing.moves[i][0];
							s = ~~oppKingSq + oppKing.moves[i][1];
						  combined = f + "" + s;
						  if (combined in this.positions) {
						  	arr.push(combined);
						  }
						}
						return arr;
					}).call(this);
					for (i = 0, len = surroundingSqs.length; i < len; i++) {
						sq = surroundingSqs[i];
						if (!this.positions[sq] || this.positions[sq].color !== opponent) {
							possibleKingMoves.push(sq);
						} 
					}
					var kingMoves = this.possibleKingMove(possibleKingMoves, oppKing.moves, opponent);
					var canBeSaved = this.canBeSaved(opponent);
					if (kingMoves.length || canBeSaved) { 
						return false; 
					} else {
						return true;
					}
				}
				Board.prototype.swap = function(color) {
					return color == "white" ? "black" : "white";
				}
				Board.prototype.canBeSaved = function(color) {
					// here we check if ANY of the opps pieces can move to one of our checkPath sqs
					var i, p, lth, len, dist, direction, j, lngth, moves, moveTo, piece, l, z, pFirstMove, pEatMove, pForwardMove;
					var resqueSqs = this.checkPaths[color];
					for (var sqr in this.positions) {
						piece = this.positions[sqr];
						if (piece && piece.color == color) {
							if (piece.multiples) {
								for (i = 0, len = resqueSqs.length; i < len; i++) {
									dist = this.distBtwnSqs(sqr, resqueSqs[i]);

									if (this.validDirection(dist)) {
										direction = this.validPieceDirection(piece, Math.abs(dist[0]), Math.abs(dist[1]), JSON.stringify(dist));
										if (direction) {
											if (this.clearPath(sqr, Math.abs(dist[0]), Math.abs(dist[1]), direction)) {
												return true;
											}
										}
									}
								}
							} else if (piece.type == "knight") {
								moves = piece.moves;
								for (j = 0, lngth = moves.length; j < lngth; j++) {
									moveTo = (~~sqr[0] + moves[j][0]) + "" + (~~sqr[1] + moves[j][1]);
									if (resqueSqs.indexOf(moveTo) != -1) {
										return true;
									}
								}
							} else {
								// we're a pawn
								for (l = 0; l < piece.eat.length; l++) {
									pEatMove = (~~sqr[0] + piece.eat[l][0]) + "" + (~~sqr[1] + piece.eat[l][1]);
									if (this.checkPaths[color + "PathHolder"] == pEatMove) {
										return true;
									}
								}
								if (this.pawnLegalMoves(sqr, piece.firstMoves[0], color)) {
									return true;
								}
								if (!piece.moved) {
									if (this.pawnLegalMoves(sqr, piece.firstMoves[1], color)) {
										return true;
									}
								} 
							}
						}
					}
					return false;
				}
				Board.prototype.pawnLegalMoves = function(sqr, move, color) {
					var mv;
					mv = (~~sqr[0] + move[0]) + "" + (~~sqr[1] + move[1]);
					if (this.checkPaths[color].indexOf(mv) != -1) {
						return true;
					} 
				}
				Board.prototype.distBtwnSqs = function(from, to) {
					// takes 2 sqs and returns an array of the shift we're trying to make
					return [~~to[0] - ~~from[0], ~~to[1] - ~~from[1]]
				}
				Board.prototype.possibleMove = function() {

				}
				Board.prototype.possibleKingMove = function(sqs, moves, opponent) {
					var i, len, k, lenth, knt, j, lngth, p, f, ff, s, ss, next, path, strMove, potentialPawnMove, pawnMoves;
					var validMoves = [];
					// we have to walk all directions until we hit one of our own, an opponent, or to the end of the board
					allSqs: for (i = 0, len = sqs.length; i < len; i++) {
						f = ~~sqs[i][0], s = ~~sqs[i][1];
						// check for knights
						for (k = 0, length = this.knightMoves.length; k < lenth; k++) {
							knt = (f + this.knightMoves[k][0]) + "" + (s + this.knightMoves[k][1]); 
							if (this.positions[knt] 
								&& this.positions[knt].type == "knight" 
								&& this.positions[knt].color != opponent) {
								continue allSqs;
							}
						}
						// check for pawns
						for (p = 0; p < 2; p++) {
							if (opponent == "black") {
								pawnMoves = [[-1, -1], [-1, 1]];
							} else if (opponent == "white") {
								pawnMoves = [[1, -1], [1, 1]];
							}
							potentialPawnMove = (f + pawnMoves[p][0]) + "" + (s + pawnMoves[p][1]);
							if (this.positions[potentialPawnMove] 
								&& this.positions[potentialPawnMove].type == "pawn"
								&& this.positions[potentialPawnMove].color != opponent) {
								continue allSqs;
							}
						}
					allMoves:	for (j = 0, lngth = moves.length; j < lngth; j++) {
							// conditions for break:
							strMove = JSON.stringify(moves[j]);
							ff = f, ss = s;
							// we reach the end of the board
							while (ff < 7 && ff > 0 && ss < 7 && ss > 0) {
								ff += moves[j][0];
								ss += moves[j][1];
								next = ff + "" + ss;
								if (this.positions[next]) {
									if (this.positions[next].color == opponent) {
										// we hit our own piece
										break;
									} else {
										if (JSON.stringify(this.positions[next].moves).indexOf(strMove) != -1) {
											continue allSqs;
											// we hit an opp piece that doesn't share the path
										} else { continue allMoves; }
									}
								}
							}
						}
						// we found a free sq
						validMoves.push(sqs[i]);
					}
					if (validMoves.length > 0) {
						this.check[opponent + "Escapes"] = validMoves;
					}
					return validMoves;
				}
				Board.prototype.movePiece = function(target, targetEl) {
					// moves the elements
					var html = this.selectedEl.innerHTML;
					this.selectedEl.innerHTML = "";
					targetEl.innerHTML = html;
					// remove selected class
					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
					// update positions
					this.positions[target] = this.positions[this.selected];
					this.positions[this.selected] = null;
					// clear selected
					this.selected = null;
					this.selectedEl = null;
				}
				Board.prototype.validMoveInCheck = function(piece, to) {
					if (piece.type == "king" 
						&& this.check[piece.color + "Escapes"].indexOf(to)) {
						this.check[piece.color] = false;
						return true;
					} else {
						if (this.checkPaths[piece.color].indexOf(to) != -1 
							|| this.checkPaths[piece.color + "PathHolder"] == to) {
							return true;
						} 
					}
				}
				Board.prototype.resetCheckProperties = function(piece, to) {	
console.log("RESETCHECKCALLED", piece.color)
					// this.check[piece.color + "Escapes"] = that pieces options  
					var pathHolder = this.checkPaths[piece.color + "PathHolder"];
					if (this.checkPaths[piece.color + "PathHolder"] == to 
						|| this.check[piece.color + "Escapes"].indexOf(to) != -1) {
// you clear the path and pathholder IF the pathholder is eaten or the king moves
						this.checkPaths[piece.color + "PathHolder"] = "";
						this.checkPaths[piece.color] = [];
						this.immobile[piece.color] = null;

					} else if (this.checkPaths[piece.color].indexOf(to) != -1) {
console.log("path blocked by another piece");
						this.immobilize(to);
console.log(this.immobile, "immobile");

						// what happens now? 
						// we need to watch and see if 
					}  else {
console.log("THIS SHOULDNT BE HAPPENING");
					}
					this.check[piece.color + "Escapes"] = [];
					this.check[piece.color] = false;
				
				}
 				Board.prototype.validMove = function(piece, from, to) {
					// are we already in check??					
 					var desiredShift = this.distBtwnSqs(from, to);
 					var desiredStr = JSON.stringify(desiredShift);
 					var spotTaken = this.spotTaken(to);
 					var diffColors = this.positions[to] && this.positions[to].color != piece.color;
 					var cornerPiece, fromRow;
 					if (piece.type == "pawn") {
// is it one of our primary moves?
						if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1) {
							if (!spotTaken) {
								if (!piece.moved) piece.moved = true;
// return to
								return true;
							}	
// are we trying to eat a piece?
						} else if (JSON.stringify(piece.eat).indexOf(desiredStr) != -1 && diffColors) {
								if (!piece.moved) piece.moved = true;
								return true;
// if nothing is valid so far, maybe it's our first move
						} else if (!piece.moved && JSON.stringify(piece.firstMoves).indexOf(desiredStr) != -1) {
// here we still need to check, is something in the way?? bc we could be moving 2 spaces up and running into something
								piece.moved = true;
								return true;
						} else {
							return false;
						}			
 					} else {
 						// we are not a pawn
 						// check if we're a king that's trying to castle 
 						if (piece.type == "king" 
 							&& !piece.moved
 							&& JSON.stringify(piece.castleMoves).indexOf(desiredStr) != -1) { 
 							fromRow = from[0];
 							if (desiredShift[1] < 0) {
 								// trying to castle left
 								cornerPiece = this.positions[fromRow + 0];
 								if (cornerPiece.type == "rook" 
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 1]
 									&& !this.positions[fromRow + 2]
 									&& !this.positions[fromRow + 3]) {
 									this.castle(piece,from,to,cornerPiece,fromRow+0,fromRow+3);
 									this.justCastled = true;
 									return true;
 								}
 							} else {
 								// trying to castle right
 								cornerPiece = this.positions[fromRow + 7];
 								if (cornerPiece.type == "rook"
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 6]
 									&& !this.positions[fromRow + 5]) {

 									this.castle(piece,from,to,cornerPiece,fromRow+7,fromRow+5);
 									this.justCastled = true;
 									return true;
 								}
 							}
						}
						if (piece.multiples && (Math.abs(desiredShift[0]) > 1 || Math.abs(desiredShift[1]) > 1)) {
							// here we check if there's anything in our way
							var r = Math.abs(desiredShift[0]);
							var c = Math.abs(desiredShift[1]);
							var dir = this.validPieceDirection(piece, r, c, desiredStr);
							if (this.validDirection(desiredShift) 
								&& dir
								&& this.clearPath(from, r, c, dir)) {
								return true;
							} else {
								return false;
							}
						} else {
							// not trying to move multiple squares
							if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1 && (diffColors || !spotTaken)) {
								return true;
							} else { return false; }
						}
 					}
 				}
 				Board.prototype.spotTaken = function(to) {
 					return this.positions[to] ?  true : false; 
 				}
 				Board.prototype.castle = function(king, kFrom, kTo, rook, rFrom, rTo) {
 					this.kings[king.color] = kTo;
					king.moved = true;
					rook.moved = true;
 					var kingHTML = this.selectedEl.innerHTML;
 					var rookEl = document.getElementsByClassName(rFrom)[0];
 					var rookHTML = rookEl.innerHTML;
 					var kToEl = document.getElementsByClassName(kTo)[0];
 					var rToEl = document.getElementsByClassName(rTo)[0];
 					this.selectedEl.innerHTML = "";
 					rookEl.innerHTML = "";
 					kToEl.innerHTML = kingHTML;
 					rToEl.innerHTML = rookHTML;
 					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
 					// update positions
 					this.positions[kTo] = this.positions[kFrom];
 					this.positions[kFrom] = null;
 					this.positions[rTo] = this.positions[rFrom];
 					this.positions[rFrom] = null;
 					// clear selected
 					this.selected = null;
 					this.selectedEl = null;
 				}
 				Board.prototype.validDirection = function(desiredShift) {
 					var r, c;
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					// is it a legal attempt?
 					var zeroIndex = desiredShift.indexOf(0);
					if (zeroIndex == -1 && r != c) {
						return false;
					} else { return true };

 				}
 				Board.prototype.validPieceDirection = function(piece, r, c, desiredStr) {
					var zero = [r,c].indexOf(0);
					for (i = 0, len = piece.moves.length; i < len; i++) {
						// run it if there is no zero, or if zeros match
						if (zero == -1 || piece.moves[i][zero] == 0) {
							if (JSON.stringify([piece.moves[i][0] * r, piece.moves[i][1] * c]) == desiredStr) {
								return piece.moves[i];
							}
						}
					}
 				}
 				Board.prototype.clearPath = function(from, r, c, direction) {
 					var startArr = [~~from[0],~~from[1]];
 					var j;
					for (j = 0; j < (Math.max(r,c)-1); j++) {
// this seems sketchy to update startArr (contender for refactor)
						startArr[0] = startArr[0] + direction[0];
						startArr[1] = startArr[1] + direction[1];
						inBtwnSq = startArr[0] + "" + startArr[1];
						if (this.positions[inBtwnSq]) {
							return false;
						}
					}
					return true;
 				}
 				Board.prototype.pathBlocked = function(piece, desiredShift, desiredStr, from, opponent) {

 					// var opponent = this.trn == "white" ? "black" : "white";
 					var non_zero, direction, inBtwnSq, r, c, i, j, len, startArr, inBtwnSqs;
 					var blockers = [];
 				// 	r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					startArr = [~~from[0],~~from[1]];
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);

					// does one of our available moves match the desired move?
					var validPD = this.validPieceDirection(piece, r, c, desiredStr);
console.log("validpd", validPD);
 					if (validPD) {
						direction = validPD;
						inBtwnSqs = [];
						// are there any of our pieces in the way?
						for (j = 0; j < (Math.max(r,c)-1); j++) {
// this seems sketchy to update startArr (contender for refactor)
							startArr[0] = startArr[0] + direction[0];
							startArr[1] = startArr[1] + direction[1];
							inBtwnSq = startArr[0] + "" + startArr[1];
console.log("inBtwnSq", inBtwnSq);
							inBtwnSqs.push(inBtwnSq);
							if (this.positions[inBtwnSq]) blockers.push(inBtwnSq);
						}
						// save them in the check path
						if (opponent) { 
							this.checkPaths[opponent] = inBtwnSqs; 
							this.checkPaths[opponent + "PathHolder"] = from;
						}
						// this means we checked all the squares and there was nothing
						if (blockers.length == 1) this.immobilize(blockers[0], opponent);
console.log(this.immobile, "this.immobile");
						return blockers.length > 0 ? blockers : false;
 					} else {
 						return true;
 					}
 				}
 				Board.prototype.immobilize = function(sq, color) {
 					// this will probably have to be an array bc of multiple pathholders
 					this.immobile[color] = sq;
 				}
				Board.prototype.setSquares = function(row, index) {
					var i, len, color;
					var cols = row.querySelectorAll("td");
					for (i = 0, len = cols.length; i < len; i++) {
						color = (i + index) % 2 == 0 ? "even" : "odd";
						cols[i].setAttribute("class", index + "" + i + " " + color);
					}
				}
				Board.prototype.set = function(positions) {
					var i, len, piece, sq;
					var positionKeys = Object.keys(positions);
					for (i = 0, len = positionKeys.length; i < len; i++) {
						piece = positions[positionKeys[i]];
						if (piece) {
							sq = document.getElementsByClassName(piece.starting_position)[0];
							var img = document.createElement("img");
							img.src = piece.src;
							sq.appendChild(img);
						}
					}
				}
				return Board;
			})();
		this._init();
		}
		return Game;
	})();
	new Game();
})();
</script>	
</body>
</html>