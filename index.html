<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>		
<style>
	table {
		border-spacing: 0;
		margin: 0 auto;
	}
	td { 
		width: 70px;
		height: 70px;
	}
	.even {
		background: #F1F5C4;
	}
	.odd {
		background: #75756E;
	}
	.selected {
		background: #F2D0C7;
	}
</style>

</head>
<body>
	<table id="board">
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
	</table>
<script>
(function(){
	var Game = (function(){
		function Game() {
			this.boardMatrix = [[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7]];
			this._init = function() {
				var i, j, len, lngth, p, pProperties, c, src, pos;
				// window.onload = function() {
				this.board = new Board();
				// board.set();
				// };
				this.board.pieces = [
				{"type": "rook", "squares": ["00","07",
				"70", "77"], "srcs": ["imgs/white_rook.png", "imgs/black_rook.png"]}, 
				{"type": "pawn", "squares": 
				["10","11","12", "13","14","15","16", "17", "60","61",
				"62", "63","64","65","66","67"], "srcs": ["imgs/white_pawn.png", "imgs/black_pawn.png"]}, 
				{"type": "knight", "squares": ["01", "06","71","76"],"srcs": ["imgs/white_knight.png", "imgs/black_knight.png"]}, 
				{"type":"bishop", "squares": ["02","05","72","75"],"srcs": ["imgs/white_bishop.png", "imgs/black_bishop.png"]}, 
				{"type":"queen", "squares": ["03","73"],"srcs": ["imgs/white_queen.png", "imgs/black_queen.png"]}, 
				{"type": "king", "squares": ["04","74"],"srcs": ["imgs/white_king.png", "imgs/black_king.png"]}];
				this.board.positions = (function() {
					var obj = {}, i, j, len = this.boardMatrix.length;
					for (i = 0; i < len; i++) {
						for (j = 0; j < len; j++) {
							obj[i+""+j] = null;
						}
					}
					return obj;
				}).call(this);

				this.board.kings = {"white": "74", "black": "04"};
				console.log(this.board.kings);

				for(i = 0, len = this.board.pieces.length; i<len; i++) {
					p = this.board.pieces[i];
					for (j = 0, lngth = p.squares.length; j < lngth; j++) {
						c = j < lngth/2 ? "black" : "white";
						src = j < lngth/2 ? p.srcs[1] : p.srcs[0];
						pos = p.squares[j];
						pProperties = {"type": p.type, "square": pos, "color": c, "src": src};
						var newPiece = new Piece(pProperties);
						this.board.positions[pos] = newPiece;
						// this.board.immobile[pos] = false;
					}
				}
				this.board.set(this.board.positions);
			}

			var Piece = (function() {
				function Piece(props) {
					this.type = props.type;
					this.starting_position = props.square;
					this.color = props.color;
					this.src = props.src;
					this.legalMoves(); 
				}
				Piece.prototype.legalMoves = function() {
					switch (this.type) {
						case "pawn":
							if (this.color == "white") {
								this.moves = [[-1,0]];
								this.eat = [[-1,-1],[-1,1]];
								this.firstMoves = [[-1,0], [-2,0]];
							} else {
								this.moves = [[1,0]];
								this.eat = [[1,1], [1,-1]];
								this.firstMoves = [[1,0], [2,0]];
							}
							this.moved = false;
							this.multiples = false;
							break;
						case "rook": 
						  this.moves = [[-1,0], [1,0], [0,-1], [0,1]];
						  this.multiples = true;
						  this.moved = false;
						  break;
						case "knight":
						  this.moves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
						  this.multiples = false;
						  break;
						case "queen":
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							break;
						case "king": 
							this.castleMoves = [[0,-2], [0,2]];
							this.moves = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,1], [1,-1]];
							this.multiples = true;
							this.moved = false;
							break;
						case "bishop":
						  this.moves = [[1,1], [-1,-1], [-1,1], [1,-1]];
						  this.multiples = true;
						  break;
					}
				}
				return Piece;
			})();
			var Board = (function() {
				function Board() {
					var i, len;
					var that = this;
					this.valid;
					this.trn = "white";
					this.justCastled;
					this.knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,2], [2,1], [1,-2], [2,-1]];
					this.check = { "white": false, "black": false };
					this.checkPaths = { "white": [], "black": [] };
console.log(this.checkPaths);
					this.board = document.getElementById("board");
					this.rows = document.querySelectorAll("tr"); 
					for (i = 0, len = this.rows.length; i < len; i++) {
						this.setSquares(this.rows[i], i);
					}
					this.board.onclick = function(e) {
						// what did we click on?
						var clicked = e.target, target, valid, piece;
						if (clicked.tagName == "TD") {
							targetEl = clicked;
							target = clicked.className.split(" ")[0];
						} else if (clicked.tagName == "IMG") {
							targetEl = clicked.parentNode;
							target = targetEl.className.split(" ")[0];
						}
						// if there was, and the target sq contains a different one of our pieces, select the other piece and unselect the old one.
						piece = that.positions[that.selected];
						if (that.selected && that.selected != target) {
							// we're not trying to move to a different square
							if (that.positions[target] && that.positions[target].color == piece.color) {
									// remove the selected class from the last element
									that.selectedEl.className = that.selectedEl.className.replace("selected", "");
									// add it to the new one
									targetEl.className += " selected";
									that.selected = target;
									that.selectedEl = targetEl;
							} else {
// that.justCastled should be a contender for refactor since we probably shouldn't be calling methods (castle) that move pieces from within validMove, so should we check here whether we're trying to castle? or within movePiece?
								that.justCastled = false;
								if (that.validMove(piece, that.selected, target)) {
									that.setCheck(piece, target);
									if (!that.justCastled) that.movePiece(target, targetEl);
									that.turn(that.trn);
									if (piece.type == "king") that.kings[piece.color] = target;
								}
							}
						} else if (that.positions[target] && that.positions[target].color == that.trn) {
							// this means nothing has been selected yet
							that.selected = target;
							that.selectedEl = targetEl;
							targetEl.className += " selected";
						}
					}
					this.turn = function(color) {
						if (color == "white") {
							this.trn = "black";
						} else {
							this.trn = "white";
						} 
					}
				}
				Board.prototype.setCheck = function(piece, newSq) {
					// are they in check?
					console.log(this.checkPaths);

					console.log(piece, newSq);
					console.log(this.trn);
					var opponent = this.trn == "white" ? "black" : "white";
					var oppInCheck = this.check[opponent];
					var type = piece.type;
					var distFromKing, oppKingSq =	this.kings[opponent];
					
					if (type == "pawn" || type == "knight") {
						var checkMoves = type == "pawn" ? piece.eat : piece.moves;
						var potentialChecks = (function() {
							var i, d1, d2, len, arr = [];
							for (i = 0, len = checkMoves.length; i < len; i++) {
								d1 = ~~newSq[0] + checkMoves[i][0];
								d2 = ~~newSq[1] + checkMoves[i][1];
								arr.push(d1 + "" + d2);
							}
							return arr;
						})();
// POTENTIAL REFACTOR BC THIS LOGIC IS BEING REPEATED IN THE ELSE STATEMENT AS WELL 
						var check = potentialChecks.indexOf(oppKingSq) == -1 ? false : true;
						if (oppInCheck != check) { this.check[opponent] = check; }
						if (this.check[opponent]) { this.checkMate(opponent); };
					} else {
						// not a knight or pawn
						// first check if it's possible
						distFromKing = [~~oppKingSq[0] - ~~newSq[0], ~~oppKingSq[1] - ~~ newSq[1]];
						if (this.validDirection(distFromKing)) {
							// it's possible that the opp is in check
							// if it's not impeded opp is in check
							console.log("OPPONENT", opponent);
							var notInCheck = this.notInCheck(piece, distFromKing, JSON.stringify(distFromKing), newSq, opponent);
							this.check[opponent] = !notInCheck;
							if (typeof notInCheck == "string") { this.immobile[notInCheck] = true; }
							if (!notInCheck) { this.checkMate(opponent, distFromKing); }
						}
					}
				}
				Board.prototype.checkMate = function(opponent, distFromKing) {
					console.log("checkMate called");
					var i, len, sq;
					var oppKingSq = this.kings[opponent];
					var oppKing = this.positions[oppKingSq];
					var possibleKingMoves = [];
					var surroundingSqs = (function() {
						var arr = [];
						var i, len, f, s, combined;
						for (i = 0, len = oppKing.moves.length; i<len; i++) {
							f = ~~oppKingSq[0] + oppKing.moves[i][0];
							s = ~~oppKingSq + oppKing.moves[i][1];
						  combined = f + "" + s;
						  if (combined in this.positions) {
						  	arr.push(combined);
						  }
						}
						return arr;
					}).call(this);
					for (i = 0, len = surroundingSqs.length; i < len; i++) {
						sq = surroundingSqs[i];
						if (!this.positions[sq] || this.positions[sq].color !== opponent) {
							possibleKingMoves.push(sq);
						} 
					}
					if (this.possibleKingMove(possibleKingMoves, oppKing.moves, opponent)) { 
						return false; 
					} else if (this.canBeSaved()) {

					}
				}
				Board.prototype.canBeSaved = function() {
					console.log("trying to save me");
				}
				Board.prototype.possibleKingMove = function(sqs, moves, opponent) {
					var i, len, k, lenth, knt, j, lngth, f, ff, s, ss, next, path, strMove;
					// we have to walk all directions until we hit one of our own, an opponent, or to the end of the board
					allSqs: for (i = 0, len = sqs.length; i < len; i++) {
						f = ~~sqs[i][0], s = ~~sqs[i][1];
						// check for knights
						for (k = 0, length = this.knightMoves.length; k < lenth; k++) {
							knt = (f + this.knightMoves[k][0]) + "" + (s + this.knightMoves[k][1]); 
							if (this.positions[knt] 
								&& this.positions[knt].type == "knight" 
								&& this.positions[knt].color != opponent) {
								continue allSqs;
							}
						}
						if (JSON.stringify(this.knightMoves))
					allMoves:	for (j = 0, lngth = moves.length; j < lngth; j++) {
							// conditions for break:
							strMove = JSON.stringify(moves[j]);
							ff = f, ss = s;
							// we reach the end of the board
							while (ff < 8 && ss < 8) {
								ff += moves[j][0];
								ss += moves[j][1];
								next = ff + "" + ss;
								if (this.positions[next]) {
									if (this.positions[next].color == opponent) {
										// we hit our own piece
										break;
									} else {
										if (JSON.stringify(this.positions[next].moves).indexOf(strMove) != -1) {
											break allMoves;
											// we hit an opp piece that doesn't share the path
										} else { break; }
									}
								}
							}
						}
						// we found a free sq
						return true;
					}
					return false;
				}
				Board.prototype.movePiece = function(target, targetEl) {
					// moves the elements
					var html = this.selectedEl.innerHTML;
					this.selectedEl.innerHTML = "";
					targetEl.innerHTML = html;
					// remove selected class
					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
					// update positions
					this.positions[target] = this.positions[this.selected];
					this.positions[this.selected] = null;
					// clear selected
					this.selected = null;
					this.selectedEl = null;
				}
 				Board.prototype.validMove = function(piece, from, to) {
 					var desiredShift = [~~to[0] - ~~from[0], ~~to[1] - ~~ from[1]];
 					var desiredStr = JSON.stringify(desiredShift);
 					var spotTaken = this.spotTaken(to);
 					var diffColors = this.positions[to] && this.positions[to].color != piece.color;
 					var cornerPiece, fromRow;
 					if (piece.type == "pawn") {
// is it one of our primary moves?
						if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1) {
							if (!spotTaken) {
								if (!piece.moved) piece.moved = true;
								return true;
							}	
// are we trying to eat a piece?
						} else if (JSON.stringify(piece.eat).indexOf(desiredStr) != -1 && diffColors) {
								if (!piece.moved) piece.moved = true;
								return true;
// if nothing is valid so far, maybe it's our first move
						} else if (!piece.moved && JSON.stringify(piece.firstMoves).indexOf(desiredStr) != -1) {
// here we still need to check, is something in the way?? bc we could be moving 2 spaces up and running into something
								piece.moved = true;
								return true;
						} else {
							return false;
						}			
 					} else {
 						// we are not a pawn
 						// check if we're a king that's trying to castle 
console.log(piece.type, !piece.moved);
 						if (piece.type == "king" 
 							&& !piece.moved
 							&& JSON.stringify(piece.castleMoves).indexOf(desiredStr) != -1) { 
console.log("im a unmoved king with a valid move in the books");
 							fromRow = from[0];
 							if (desiredShift[1] < 0) {
 								// trying to castle left
 								cornerPiece = this.positions[fromRow + 0];
 								if (cornerPiece.type == "rook" 
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 1]
 									&& !this.positions[fromRow + 2]
 									&& !this.positions[fromRow + 3]) {
 									this.castle(piece,from,to,cornerPiece,fromRow+0,fromRow+3);
 									this.justCastled = true;
 									return true;
 								console.log("castleLeft");
 								}
 							} else {
 								// trying to castle right
 								cornerPiece = this.positions[fromRow + 7];
 								if (cornerPiece.type == "rook"
 									&& !cornerPiece.moved
 									&& !this.positions[fromRow + 6]
 									&& !this.positions[fromRow + 5]) {

 									this.castle(piece,from,to,cornerPiece,fromRow+7,fromRow+5);
 									this.justCastled = true;
 									return true;
 								console.log("castleRight");
 								}
 							}
						}
						if (piece.multiples && (Math.abs(desiredShift[0]) > 1 || Math.abs(desiredShift[1]) > 1)) {
							// here we check if there's anything in our way
							if (this.validDirection(desiredShift) && !this.notInCheck(piece, desiredShift, desiredStr, from)){
								return true;
							} else {
								return false;
							}
						} else {
							// not trying to move multiple squares
							if (JSON.stringify(piece.moves).indexOf(desiredStr) != -1 && (diffColors || !spotTaken)) {
								return true;
							} else { return false; }
						}
 					}
 				}
 				Board.prototype.spotTaken = function(to) {
 					return this.positions[to] ?  true : false; 
 				}
 				Board.prototype.castle = function(king, kFrom, kTo, rook, rFrom, rTo) {
 					this.kings[king.color] = kTo;
					king.moved = true;
					rook.moved = true;
 					var kingHTML = this.selectedEl.innerHTML;
 					var rookEl = document.getElementsByClassName(rFrom)[0];
 					var rookHTML = rookEl.innerHTML;
 					var kToEl = document.getElementsByClassName(kTo)[0];
 					var rToEl = document.getElementsByClassName(rTo)[0];
 					this.selectedEl.innerHTML = "";
 					rookEl.innerHTML = "";
 					kToEl.innerHTML = kingHTML;
 					rToEl.innerHTML = rookHTML;
 					this.selectedEl.className = this.selectedEl.className.replace("selected", "");
 					// update positions
 					this.positions[kTo] = this.positions[kFrom];
 					this.positions[kFrom] = null;
 					this.positions[rTo] = this.positions[rFrom];
 					this.positions[rFrom] = null;
 					// clear selected
 					this.selected = null;
 					this.selectedEl = null;
 				}
 				Board.prototype.validDirection = function(desiredShift) {
 					var r, c;
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					// is it a legal attempt?
 					var zeroIndex = desiredShift.indexOf(0);
					if (zeroIndex == -1 && r != c) {
						return false;
					} else { return true };

 				}
 				Board.prototype.validPieceDirection = function(piece, r, c, desiredStr) {
 					for (i = 0, len = piece.moves.length; i < len; i++) {
 						if (JSON.stringify([piece.moves[i][0] * r, piece.moves[i][1] * c]) == desiredStr) {
 							return piece.moves[i];
 						}
 					}
 				}	
 				Board.prototype.notInCheck = function(piece, desiredShift, desiredStr, from, opponent) {
 					// var opponent = this.trn == "white" ? "black" : "white";
 					var non_zero, direction, inBtwnSq, r, c, i, j, len, startArr, inBtwnSqs;
 				// 	r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);
 					startArr = [~~from[0],~~from[1]];
 					r = Math.abs(desiredShift[0]), c = Math.abs(desiredShift[1]);

					// does one of our available moves match the desired move?
					var validPD = this.validPieceDirection(piece, r, c, desiredStr);
 					if (validPD) {
						direction = validPD;
						inBtwnSqs = [];
						// are there any of our pieces in the way?
						for (j = 0; j < (Math.max(r,c)-1); j++) {
// this seems sketchy to update startArr (contender for refactor)
							startArr[0] = startArr[0] + direction[0];
							startArr[1] = startArr[1] + direction[1];
							inBtwnSq = startArr[0] + "" + startArr[1];
							if (this.positions[inBtwnSq]) { 
								inBtwnSqs = [];
								return inBtwnSq; 
							} else {
								inBtwnSqs.push(inBtwnSq);
							}
						}
						// this means we checked all the squares and there was nothing
						// save them in the check path
						inBtwnSqs.push(from);
						if (opponent) this.checkPaths[opponent] = inBtwnSqs;
console.log(this.checkPaths);
						return false;
 					} else {
 						return true;
 					}
 				}

				Board.prototype.setSquares = function(row, index) {
					var i, len, color;
					var cols = row.querySelectorAll("td");
					for (i = 0, len = cols.length; i < len; i++) {
						color = (i + index) % 2 == 0 ? "even" : "odd";
						cols[i].setAttribute("class", index + "" + i + " " + color);
					}
				}
				Board.prototype.set = function(positions) {
					var i, len, piece, sq;
					var positionKeys = Object.keys(positions);
					for (i = 0, len = positionKeys.length; i < len; i++) {
						piece = positions[positionKeys[i]];
						if (piece) {
							sq = document.getElementsByClassName(piece.starting_position)[0];
							var img = document.createElement("img");
							img.src = piece.src;
							sq.appendChild(img);
						}
					}
				}
				return Board;
			})();
		this._init();
		}
		return Game;
	})();
	new Game();
})();
</script>	
</body>
</html>